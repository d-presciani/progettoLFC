\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{fancyhdr}
\usepackage[margin=2cm]{geometry}
\usepackage{tocloft}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{graphicx}

\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\renewcommand{\thesection}{\arabic{section}.}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}

\setlength{\headheight}{15pt}

\pagestyle{fancy}
\renewcommand{\footrulewidth}{0.4pt}
\lhead{\bfseries Requisiti di sistema}
\chead{}
\rhead{}
\lfoot{}
\cfoot{}
\rfoot{\thepage}

\begin{document}
\tableofcontents

\pagebreak

\section{Prefazione}

\subsection{Version History}

Versione 0.0 - 16/04/2019

\subsection{Sommario modifiche}
Definizione dei requisiti funzionali, dei casi d'uso, della struttura generale del software, della struttura dei test e degli strumenti utilizzati per lo sviluppo.

\pagebreak

\section{Introduzione}

\subsection{Definizioni e glossario}
\subsubsection*{Grammatica libera da contesto}
In informatica e in linguistica, una grammatica libera dal contesto è una grammatica formale in cui
ogni regola sintattica è espressa sotto forma di derivazione di un simbolo a sinistra a partire da uno
o più simboli a destra. \par
Ciò può essere espresso con due simbolismi equivalenti:
\begin{enumerate}[label=\arabic*)]
\item $S := \alpha$
\item $S \to \alpha$
\end{enumerate}
dove $S$ è un simbolo detto \textit{non terminale}, sostituibile con altri simboli non terminali e/o con simboli terminali, e $\alpha$ è una sequenza di simboli non terminali e/o terminali, ossia simboli che non possono essere sostituiti con null'altro. \par
L'espressione "libera dal contesto" si riferisce al fatto che il simbolo non terminale $S$ può sempre
essere sostituito da $\alpha$, indipendentemente dai simboli che lo precedono o lo seguono; un linguaggio
formale si dice libero dal contesto se esiste una grammatica libera dal contesto che lo genera.
\subsubsection*{Parser}
Un parser LR è un parser di tipo bottom-up per grammatiche libere da contesto che legge il proprio input partendo da sinistra verso destra, producendo una derivazione a destra. Laddove indicato come parser $LR \left( k \right)$, il $k$ si riferisce al numero di simboli letti (ma non "consumati") per prendere le decisioni di parsing.

\subsection{Scopo}
Scopo dell'applicazione che si andrà a realizzare è il riconoscimento di una grammatica LR(1) contenuta in un file di input selezionato dall'utente. \par

\pagebreak

\section{Requisiti funzionali}

L'applicazione deve consentire all'utente le seguenti azioni:
\begin{itemize}
\item selezione del file di input da sottoporre al parsing e all'identificazione.
\end{itemize}
L'applicazione deve fornire le seguenti funzionalità:
\begin{itemize}
\item effettuare il parsing del file ricevuto in input, individuando eventuali errori sintattici, lessicali o semantici;
\item qualora vengano individuati errori di qualsiasi genere nella fase di parsing, l'applicazione deve comunicare i dettagli relativi agli errori individuati all'utente;
\item qualora non vengano individuati errori nella fase di parsing, l'applicazione deve procedere nell'identificare la grammatica come grammatica $LR \left( 1 \right)$ o non $LR \left( 1 \right)$.
\end{itemize}  

\subsection{Struttura corretta della grammatica}\label{struttura}
L'applicazione deve riconoscere come formalmente corrette (quindi prive di errori sintattici, lessicali e/o grammaticali) soltanto grammatiche che presentino la seguente struttura:
\begin{itemize}
\item una prima regola $pr$ che abbia come elemento di sinistra il non terminale $S0$, definita come segue
$$
SZ \hspace{5pt} EQ \hspace{5pt} NT \hspace{5pt} TER \hspace{5pt} SC
$$
\item altre $n \geq 1$ regole di produzione $ar$, che formano il resto della grammatica, definite come segue
$$
NT \hspace{5pt} EQ \hspace{5pt} \left( NT \left| T \right. \right)^* \hspace{5pt} SC
$$
\end{itemize}
I blocchi componenti le regole appena definite sono così traducibili:
\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
\textbf{Simbolo} & \textbf{Caratteri} \\
\hline
$SZ$ & $S0$ \\
\hline
$EQ$ & $-> \left| \hspace{5pt} := \right.$ \\
\hline
$NT$ & $A \hspace{5pt} \dots \hspace{5pt} Z$ \\
\hline
$CT$ & $a \hspace{3pt} \dots z \left| \hspace{3pt} 0 \hspace{3pt} \dots \hspace{3pt} 9 \hspace{3pt} \right| \hspace{3pt} + \hspace{3pt} \left| \hspace{3pt} - \hspace{3pt} \right| \hspace{3pt} * \hspace{3pt} \left| \hspace{3pt} / \right.$ \\
\hline
$TER$ & $\text{/swa} \hspace{5pt} \left| \hspace{5pt} \text{/cjswa} \right.$ \\
\hline
$SC$ & $;$ \\
\hline
\end{tabular}
\caption{Corrispondenza tra caratteri della grammatica e blocchi di definizione delle regole}
\end{table}

\underline{Nota:} Per la definizione della struttura delle regole è stata utilizzata la notazione formale di Backus-Naur estesa (EBNF).

\subsection{Errori lessicali}
L'utilizzo di qualsiasi carattere non riconducibile alla colonna "Caratteri" della Tabella 1 corrisponde a un errore lessicale.

\subsection{Errori sintattici}
Gli errori sintattici sono dati dal mancato rispetto della struttura delle regole $pr$ e $ar$ come definite nel paragrafo "Struttura corretta della grammatica" a pagina \pageref{struttura}.

\subsection{Errori semantici}
Gli errori semantici si verificano nei seguenti casi:
\begin{itemize}
\item nella grammatica è presente un carattere non terminale che non presenta regole di produzioni associate;
\item nella grammatica è presente una regola duplicata (\underline{nota bene} questo \underline{non} è un errore bloccante).
\end{itemize}

\end{document}